<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phuket Places: A Multiplayer Learning App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 600px;
            width: 95%;
            padding: 2.5rem;
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.3s ease-in-out;
        }
        .container:hover {
            transform: translateY(-5px);
        }
        .microphone-button {
            transition: all 0.3s ease-in-out;
        }
        .microphone-button.listening {
            animation: pulse-ring 1.2s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
        .feedback {
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            margin-top: 1.5rem;
            color: #ffffff;
            transition: all 0.3s ease-in-out;
            transform: scale(0.95);
            opacity: 0;
            display: none;
        }
        .feedback.show {
            transform: scale(1);
            opacity: 1;
            display: block;
        }
        @keyframes pulse-ring {
            0% {
                transform: scale(0.3);
                opacity: 0.8;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
        .image-container {
            height: 250px;
            overflow: hidden;
            border-radius: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="container">
        <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900 mb-6">Guess the Place</h1>
        
        <!-- Added onerror attribute to provide a fallback image if the main image fails to load. -->
        <div class="image-container mb-6">
            <img id="location-image" src="" alt="Location image" onerror="this.onerror=null; this.src='https://placehold.co/600x400/cccccc/000000?text=Image+Not+Found';">
        </div>

        <p class="text-lg text-gray-700 mb-6" id="question-text">Where is this place?</p>
        
        <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
            <button id="speak-btn" class="microphone-button inline-flex items-center justify-center p-3 rounded-full bg-blue-600 text-white shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-300">
                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 8a3 3 0 100 6 3 3 0 000-6zM10 0a10 10 0 100 20 10 10 0 000-20zm0 18a8 8 0 110-16 8 8 0 010 16zM10 5a1 1 0 00-1 1v6a1 1 0 102 0V6a1 1 0 00-1-1z"/></svg>
            </button>
            <button id="read-aloud-btn" class="px-6 py-3 bg-purple-600 text-white font-bold rounded-full shadow-lg hover:bg-purple-700 focus:outline-none focus:ring-4 focus:ring-purple-300 transition-all duration-300">
                ✨ Read Aloud
            </button>
            <button id="gemini-info-btn" class="px-6 py-3 bg-green-600 text-white font-bold rounded-full shadow-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-300">
                ✨ More Info
            </button>
            <button id="skip-btn" class="px-6 py-3 bg-gray-400 text-white font-bold rounded-full shadow-lg hover:bg-gray-500 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-300">
                Next
            </button>
        </div>
        
        <p id="transcript-text" class="text-sm md:text-base text-gray-500 mt-4 mb-4" style="min-height: 1.5rem;">Waiting for your answer...</p>
        
        <div id="feedback-message" class="feedback"></div>

        <button id="next-btn" class="mt-6 px-8 py-3 bg-gray-300 text-gray-800 font-bold rounded-full shadow-lg hover:bg-gray-400 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-300">
            Next
        </button>
        
        <div id="info-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden">
            <div class="relative top-20 mx-auto p-5 border w-11/12 md:w-3/4 lg:w-1/2 shadow-lg rounded-md bg-white">
                <div class="text-left">
                    <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4" id="modal-title">More Information</h3>
                    <div class="mt-2 text-sm text-gray-500" id="modal-content">
                        <!-- Content will be injected here -->
                    </div>
                    <div class="mt-4 text-center">
                        <button id="close-modal-btn" class="px-4 py-2 bg-blue-600 text-white font-bold rounded-full">Close</button>
                    </div>
                    
                </div>
            </div>
        </div>

        <p id="user-id-display" class="mt-4 text-xs text-gray-400"></p>
        
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, orderBy, limit, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const API_KEY = ""; // Leave this empty, it will be provided by the runtime
        const GENERATE_CONTENT_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
        const TTS_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;

        // Global variables for Firebase configuration, provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // UI elements
        const speakBtn = document.getElementById('speak-btn');
        const nextBtn = document.getElementById('next-btn');
        const skipBtn = document.getElementById('skip-btn');
        const locationImage = document.getElementById('location-image');
        const transcriptText = document.getElementById('transcript-text');
        const feedbackMessage = document.getElementById('feedback-message');
        const questionText = document.getElementById('question-text');
        const geminiInfoBtn = document.getElementById('gemini-info-btn');
        const infoModal = document.getElementById('info-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const readAloudBtn = document.getElementById('read-aloud-btn');
        const userIdDisplay = document.getElementById('user-id-display');

        // Questions data with more reliable image URLs.
        // Images are sourced from Wikimedia Commons and Pexels, which are generally more stable than random URLs.
        const questions = [
            {
                image: "https://upload.wikimedia.org/wikipedia/commons/e/e6/Phromthep_Cape_Phuket_Thailand_01.jpg",
                question: "This cape is one of the most famous sunset viewpoints in Phuket. What is its name?",
                correctAnswer: "Phromthep Cape"
            },
            {
                image: "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Patong_Beach%2C_Phuket.jpg/1280px-Patong_Beach%2C_Phuket.jpg",
                question: "Which popular beach is known for its vibrant nightlife?",
                correctAnswer: "Patong Beach"
            },
            {
                image: "https://upload.wikimedia.org/wikipedia/commons/f/f6/Phuket_Town_Old_Sino-Portuguese_building.jpg",
                question: "Where is this place?",
                correctAnswer: "Phuket Old Town"
            },
            {
                image: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Big_Buddha%2C_Phuket.jpg/1920px-Big_Buddha%2C_Phuket.jpg",
                question: "This large statue is located on Nakkerd Hill. What is it called?",
                correctAnswer: "Big Buddha"
            },
            {
                image: "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Wat_Chalong%2C_Phuket.jpg/1280px-Wat_Chalong%2C_Phuket.jpg",
                question: "This is one of the most important Buddhist temples in Phuket. What is its name?",
                correctAnswer: "Chalong Temple"
            },
            {
                image: "https://upload.wikimedia.org/wikipedia/commons/2/2f/Chillva_Market_Phuket.jpg",
                question: "Which famous night market in Phuket is known for its container shops and bohemian vibe?",
                correctAnswer: "Chillva Night Market"
            },
            {
                image: "https://images.pexels.com/photos/1018698/pexels-photo-1018698.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2",
                question: "This place offers a breathtaking panoramic view of the coastline and is a popular spot for hiking. What is it called?",
                correctAnswer: "Laem Krating"
            }
        ];
        
        // Multiplayer game state
        let gameState = {
            currentQuestionIndex: 0,
            lastUpdatedBy: '',
            lastFeedback: '',
            lastCorrectAnswer: ''
        };

        // Paths for Firestore
        const gameStateDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'phuket_game_state', 'game_state');
        
        // Function to show modal
        function showModal(title, content) {
            modalTitle.textContent = title;
            modalContent.textContent = content;
            infoModal.classList.remove('hidden');
        }

        // Function to close modal
        closeModalBtn.addEventListener('click', () => {
            infoModal.classList.add('hidden');
        });
        window.addEventListener('click', (event) => {
            if (event.target === infoModal) {
                infoModal.classList.add('hidden');
            }
        });

        // A helper function for fuzzy string matching.
        function isCloseMatch(input, target) {
            const normalizedInput = input.trim().toLowerCase();
            const normalizedTarget = target.trim().toLowerCase();

            // Check for direct inclusion
            if (normalizedInput.includes(normalizedTarget)) {
                return true;
            }

            // Check for phonetic similarities (very basic)
            const phoneticMap = {
                'chalong': ['chalong', 'chalang'],
                'phromthep': ['promtep', 'phromthape'],
                'buddha': ['buda', 'butha'],
                'patong': ['patong'],
                'old phuket town': ['old phuket town', 'old phuket'],
                'chillva night market': ['chillva', 'chilwa', 'chillva market'],
                'laem krating': ['laem krating', 'lame krating', 'laem krating']
            };

            for (const key in phoneticMap) {
                if (normalizedTarget.includes(key)) {
                    for (const variant of phoneticMap[key]) {
                        if (normalizedInput.includes(variant)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- Firebase setup and real-time updates ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                console.log("User signed in:", user.uid);
                userIdDisplay.textContent = `User ID: ${user.uid}`;
                
                // Set up the real-time listener for the game state
                onSnapshot(gameStateDocRef, (docSnapshot) => {
                    if (docSnapshot.exists()) {
                        gameState = docSnapshot.data();
                        console.log("Game state updated:", gameState);
                        // Update UI based on new game state
                        const currentQuestion = questions[gameState.currentQuestionIndex];
                        locationImage.src = currentQuestion.image;
                        questionText.textContent = currentQuestion.question;
                        
                        // Display feedback from the last player
                        if (gameState.lastFeedback) {
                            feedbackMessage.textContent = gameState.lastFeedback;
                            feedbackMessage.className = `feedback show ${gameState.lastFeedback.includes('Correct') ? 'bg-green-500' : 'bg-red-500'}`;
                        } else {
                            feedbackMessage.classList.remove('show', 'bg-green-500', 'bg-red-500');
                        }

                        // Display last answer transcript
                        if (gameState.lastAnswer) {
                            transcriptText.textContent = `You said: "${gameState.lastAnswer}" (from ${gameState.lastUpdatedBy})`;
                        } else {
                            transcriptText.textContent = 'Waiting for your answer...';
                        }
                        
                    } else {
                        // Game state document does not exist, initialize it
                        console.log("Initializing new game state.");
                        updateGameState({ currentQuestionIndex: 0, lastUpdatedBy: '', lastFeedback: '', lastAnswer: '' });
                    }
                });
            } else {
                console.log("No user signed in. Signing in anonymously...");
                if (authToken) {
                    await signInWithCustomToken(auth, authToken);
                } else {
                    await signInAnonymously(auth);
                }
            }
        });

        // Function to update the game state in Firestore
        async function updateGameState(updates) {
            try {
                await setDoc(gameStateDocRef, updates, { merge: true });
                console.log("Game state updated successfully!");
            } catch (error) {
                console.error("Error updating game state:", error);
            }
        }

        // --- Function to update UI with current question ---
        function loadNextQuestion() {
            const nextIndex = (gameState.currentQuestionIndex + 1) % questions.length;
            updateGameState({ 
                currentQuestionIndex: nextIndex,
                lastUpdatedBy: auth.currentUser.uid,
                lastFeedback: '',
                lastAnswer: ''
            });
        }

        // --- Event listener for the Speak button ---
        if ('webkitSpeechRecognition' in window) {
            const recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;

            speakBtn.addEventListener('click', () => {
                recognition.start();
                transcriptText.textContent = 'Listening... Please say the answer.';
                speakBtn.classList.add('listening');
            });

            recognition.onresult = async (event) => {
                const result = event.results[0][0].transcript;
                const currentCorrectAnswer = questions[gameState.currentQuestionIndex].correctAnswer;
                
                let newFeedback = '';
                if (isCloseMatch(result, currentCorrectAnswer)) {
                    newFeedback = 'Excellent! That is correct!';
                } else {
                    newFeedback = 'Not quite right. Please try again!';
                }

                await updateGameState({
                    lastAnswer: result,
                    lastUpdatedBy: auth.currentUser.uid,
                    lastFeedback: newFeedback
                });

                speakBtn.classList.remove('listening');
            };
            
            recognition.onerror = (event) => {
                transcriptText.textContent = 'An error occurred with speech recognition: ' + event.error;
                speakBtn.classList.remove('listening');
            };
        } else {
            const noSupportMessage = document.createElement('p');
            noSupportMessage.textContent = 'Your browser does not support Speech Recognition. Please use Google Chrome or Microsoft Edge.';
            noSupportMessage.className = 'text-red-500 mt-4';
            document.querySelector('.container').appendChild(noSupportMessage);
        }

        // --- Next button event listener ---
        nextBtn.addEventListener('click', loadNextQuestion);
        
        // --- Skip button event listener ---
        skipBtn.addEventListener('click', loadNextQuestion);

        // --- Gemini API Call for more info ---
        geminiInfoBtn.addEventListener('click', async () => {
            const placeName = questions[gameState.currentQuestionIndex].correctAnswer;
            showModal('Fetching Information...', 'Please wait...');
            
            const prompt = `Write a short description (about 2-3 sentences) about the place named "${placeName}" in English, suitable for primary school students. The description should be interesting and easy to understand.`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: "You are a helpful teaching assistant specializing in history and landmarks." }]
                }
            };

            try {
                const response = await fetch(GENERATE_CONTENT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    modalTitle.textContent = `More Info About ${placeName}`;
                    modalContent.textContent = text;
                } else {
                    modalTitle.textContent = 'Error';
                    modalContent.textContent = 'Unable to retrieve information at this time.';
                }
            } catch (error) {
                modalTitle.textContent = 'Error';
                modalContent.textContent = 'An error occurred with the connection: ' + error.message;
            }
        });

        // --- Gemini TTS API Call for text-to-speech ---
        readAloudBtn.addEventListener('click', async () => {
            const textToSpeak = questions[gameState.currentQuestionIndex].correctAnswer;
            if (!textToSpeak) return;

            const payload = {
                contents: [{ parts: [{ text: textToSpeak }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Fenrir" }
                        }
                    }
                },
            };
            
            try {
                const response = await fetch(TTS_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const base64ToArrayBuffer = (base64) => {
                        const binaryString = atob(base64);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                    };
                    const pcmToWav = (pcm16, sampleRate) => {
                        const dataLength = pcm16.length * 2;
                        const buffer = new ArrayBuffer(44 + dataLength);
                        const view = new DataView(buffer);
                        
                        // WAV header
                        writeString(view, 0, 'RIFF');
                        view.setUint32(4, 36 + dataLength, true);
                        writeString(view, 8, 'WAVE');
                        writeString(view, 12, 'fmt ');
                        view.setUint32(16, 16, true);
                        view.setUint16(20, 1, true); // PCM format
                        view.setUint16(22, 1, true); // Number of channels
                        view.setUint32(24, sampleRate, true);
                        view.setUint32(28, sampleRate * 2, true);
                        view.setUint16(32, 2, true);
                        view.setUint16(34, 16, true);
                        writeString(view, 36, 'data');
                        view.setUint32(40, dataLength, true);
                        
                        // PCM data
                        let offset = 44;
                        for (let i = 0; i < pcm16.length; i++, offset += 2) {
                            view.setInt16(offset, pcm16[i], true);
                        }
                        
                        return new Blob([view], { type: 'audio/wav' });
                    };
                    const writeString = (view, offset, string) => {
                        for (let i = 0; i < string.length; i++) {
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    };
                    const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    console.error('Failed to get audio data.');
                }
            } catch (error) {
                console.error('Error fetching audio:', error);
            }
        });

        // Initial load
        window.onload = () => {
             // onSnapshot will handle the first render after authentication
        };
    </script>
</body>
</html>
